// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
  output   = "../generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ===========================================
// ENUMS
// ===========================================
enum SubscriptionPaymentStatus {
  Pending
  Succeed
  Failed
  Canceled
}

enum ContactServiceType {
  VENDOR
  CUSTOMER
  EMPLOYEE
  OTHER
}

enum VendorStatus {
  overdue
  unpaid
}

enum DiscountType {
  Amount
  Percentage
}

// ===========================================
// BUSINESS MODELS
// ===========================================

model Option {
  id        Int      @id @default(autoincrement())
  tenantId  Int
  group     String
  key       String
  value     String   @default("") // Can store as stringified JSON or basic value
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relationships
  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@unique([tenantId, group, key]) // Prevent duplicate settings per tenant
  @@map("options") // Maps to actual DB table name
}

model BankRule {
  id                     Int                  @id @default(autoincrement())
  tenantId              Int
  name                  String
  order                 Int
  applyIfAccountId      Int?
  applyIfTransactionType String?
  assignCategory        String?
  assignAccountId       Int?
  assignPayee           String?
  assignMemo            String?
  conditionsType        String?
  createdAt             DateTime             @default(now())
  updatedAt             DateTime             @updatedAt

  // Relations
  conditions            BankRuleCondition[]
  assignAccount         Account?             @relation(fields: [assignAccountId], references: [id])
  tenant                Tenant               @relation(fields: [tenantId], references: [id])

  @@map("bank_rules")
}

model BankRuleCondition {
  id        Int      @id @default(autoincrement())
  tenantId  Int
  ruleId    Int      // Foreign key to BankRule
  field     String   // Example condition field (e.g., "description")
  operator  String   // e.g., "contains", "equals"
  value     String   // the value to check
  // No timestamps (per Objection model)

  // Relations
  rule      BankRule @relation(fields: [ruleId], references: [id])
  tenant    Tenant   @relation(fields: [tenantId], references: [id])

  @@map("bank_rule_conditions")
}

model Contact {
  id                            String   @id @default(uuid())
  tenantId                      String
  displayName                   String?
  firstName                     String?
  lastName                      String?
  companyName                   String?
  email                         String?
  workPhone                     String?
  personalPhone                 String?
  website                       String?
  openingBalance                Float?   @default(0)
  openingBalanceExchangeRate    Float?   @default(1)
  openingBalanceAt              DateTime?
  balance                       Float?   @default(0)
  currencyCode                  String?
  note                          String?
  active                        Boolean  @default(true)
  contactService                ContactServiceType @default(VENDOR)

  // Billing address
  billingAddress1               String?
  billingAddress2               String?
  billingAddressCity            String?
  billingAddressState           String?
  billingAddressPostcode        String?
  billingAddressCountry         String?
  billingAddressPhone           String?

  // Shipping address
  shippingAddress1              String?
  shippingAddress2              String?
  shippingAddressCity           String?
  shippingAddressState          String?
  shippingAddressPostcode       String?
  shippingAddressCountry        String?
  shippingAddressPhone          String?

  createdAt                     DateTime  @default(now())
  updatedAt                     DateTime  @updatedAt

  tenant                        Tenant    @relation(fields: [tenantId], references: [id])
  bills                         Bill[]    @relation("VendorBills")

  @@map("contacts")
}

model PaymentIntegration {
  id             Int      @id @default(autoincrement())
  service        String
  paymentEnabled Boolean
  payoutEnabled  Boolean
  accountId      String?

  // JSON field for options (e.g., bankAccountId, clearingAccountId)
  options        Json?

  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  @@map("payment_integrations")
}

model PaymentReceive {
  id                 String   @id @default(uuid())
  tenantId           String
  customerId         String?
  depositAccountId   String?
  branchId           String?
  pdfTemplateId      String?

  paymentReceiveNo   String?
  referenceNo        String?
  statement          String?
  amount             Float    @default(0)
  paymentAmount      Float    @default(0)
  exchangeRate       Float    @default(1)
  date               DateTime
  notes              String?
  isDraft            Boolean  @default(false)

  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  // Relations
  tenant             Tenant      @relation(fields: [tenantId], references: [id])
  customer           Contact?    @relation(fields: [customerId], references: [id])
  depositAccount     Account?    @relation(fields: [depositAccountId], references: [id])
  branch             Branch?     @relation(fields: [branchId], references: [id])
  pdfTemplate        PdfTemplate? @relation(fields: [pdfTemplateId], references: [id])

  entries            PaymentReceiveEntry[]
  transactions       AccountTransaction[] @relation("PaymentReceiveTransactions")
  attachments        DocumentLink[]       @relation("PaymentReceiveDocuments")

  @@map("payment_receives")
}

model ItemCategory {
  id          Int      @id @default(autoincrement())
  tenantId    Int
  name        String
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  tenant      Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  items       Item[]

  @@map("items_categories")
}

model Media {
  id         Int          @id @default(autoincrement())
  createdAt  DateTime?    @map("created_at")
  updatedAt  DateTime?    @map("updated_at")
  // Add other fields as needed, e.g.:
  // url        String?
  // type       String?
  // size       Int?
  // tenantId   Int?

  links      MediaLink[]  @relation("MediaToLinks")

  @@map("media")
}

model MediaLink {
  id        Int      @id @default(autoincrement())
  mediaId   Int
  modelId   Int?
  modelName String?
  // Add other fields as needed

  media     Media    @relation("MediaToLinks", fields: [mediaId], references: [id])

  @@map("media_links")
}

model PdfTemplate {
  id           Int      @id @default(autoincrement())
  templateName String
  attributes   Json?

  createdAt    DateTime @map("created_at")
  updatedAt    DateTime @map("updated_at")

  @@map("pdf_templates")
}

model Role {
  id            Int               @id @default(autoincrement())
  name          String
  tenantId      String
  tenant        Tenant            @relation(fields: [tenantId], references: [id])
  permissions   RolePermission[] 

  createdAt     DateTime?         @map("created_at")
  updatedAt     DateTime?         @map("updated_at")

  @@map("roles")
}

model RolePermission {
  id         Int    @id @default(autoincrement())
  roleId     Int
  permission String
  tenantId   String
  tenant     Tenant @relation(fields: [tenantId], references: [id])
  role       Role   @relation(fields: [roleId], references: [id])

  createdAt  DateTime? @map("created_at")
  updatedAt  DateTime? @map("updated_at")

  @@map("role_permissions")
}

model User {
  id                Int       @id @default(autoincrement())
  firstName         String
  lastName          String
  email             String    @unique
  roleId            Int
  role              Role      @relation(fields: [roleId], references: [id])
  inviteAcceptedAt  DateTime?
  tenantId          String
  tenant            Tenant    @relation(fields: [tenantId], references: [id])

  createdAt         DateTime? @map("created_at")
  updatedAt         DateTime? @map("updated_at")

  @@map("users")
}

model Document {
  id         Int              @id @default(autoincrement())
  createdAt  DateTime?        @map("created_at")
  updatedAt  DateTime?        @map("updated_at")
  // You might need: name, url, type, size, etc.
  // tenantId   Int?

  links      DocumentLink[]   @relation("DocumentToLinks")

  @@map("documents")
}

model DocumentLink {
  id         Int        @id @default(autoincrement())
  documentId Int
  modelId    Int?       // the ID of the linked entity (invoice, etc.)
  modelName  String?    // name of the entity type (e.g. "Invoice")

  document   Document   @relation("DocumentToLinks", fields: [documentId], references: [id])

  createdAt  DateTime?  @map("created_at")
  updatedAt  DateTime?  @map("updated_at")

  @@map("document_links")
}

model Currency {
  id         Int       @id @default(autoincrement())
  code       String    @unique   // e.g., "USD"
  symbol     String?              // e.g., "$"
  name       String?              // e.g., "US Dollar"
  tenantId   Int?
  createdAt  DateTime? @map("created_at")
  updatedAt  DateTime? @map("updated_at")

  @@map("currencies")
}

model ExchangeRate {
  id           Int       @id @default(autoincrement())
  currencyCode String?   @map("currency_code")  // optional legacy support
  exchangeRate Float     @map("exchange_rate")
  date         DateTime
  tenantId     Int?
  createdAt    DateTime? @map("created_at")
  updatedAt    DateTime? @map("updated_at")

  // New field to properly relate to Currency
  currencyId   Int?
  currency     Currency? @relation(fields: [currencyId], references: [id])

  @@map("exchange_rates")
}

model AccountTransaction {
  id              Int       @id @default(autoincrement())
  accountId       Int
  contactId       Int?      // optional
  referenceType   String
  transactionType String
  credit          Float     @default(0)
  debit           Float     @default(0)
  exchangeRate    Float     @default(1)
  taxRate         Float?    @default(0)
  date            DateTime
  createdAt       DateTime  @default(now())

  // Relations
  account         Account   @relation(fields: [accountId], references: [id])
  contact         Contact?  @relation(fields: [contactId], references: [id])

  @@map("accounts_transactions")
}


model SaleReceipt {
  id                String               @id @default(uuid())
  receiptNumber     String?
  referenceNo       String?
  amount            Float
  exchangeRate      Float
  discount          Float?
  discountType      DiscountType?
  adjustment        Float?
  closedAt          DateTime?
  createdAt         DateTime            @default(now())
  updatedAt         DateTime            @updatedAt

  customerId        String?
  depositAccountId  String?
  branchId          String?
  warehouseId       String?

  customer          Contact?            @relation(fields: [customerId], references: [id])
  depositAccount    Account?            @relation(fields: [depositAccountId], references: [id])
  branch            Branch?             @relation(fields: [branchId], references: [id])
  warehouse         Warehouse?          @relation(fields: [warehouseId], references: [id])

  entries           ItemEntry[]         @relation("SaleReceiptEntries")
  transactions      AccountTransaction[]@relation("SaleReceiptTransactions")
  attachments       Document[]          @relation("SaleReceiptAttachments", through: DocumentLink)

  @@map("sales_receipts")
}

model SaleReceiptEntry {
  id               Int          @id @default(autoincrement())
  saleReceiptId    Int

  saleReceipt      SaleReceipt  @relation(fields: [saleReceiptId], references: [id])

  @@map("sales_receipt_entries")
}

model SaleInvoice {
  id                           String     @id @default(cuid())
  customerId                  String?
  branchId                    String?
  warehouseId                 String?
  writtenoffExpenseAccountId  String?
  pdfTemplateId               String?
  invoiceNo                   String
  referenceNo                 String?
  invoiceDate                 DateTime?
  dueDate                     DateTime?
  deliveredAt                 DateTime?
  writtenoffAt                DateTime?
  discount                    Float?
  discountType                String?
  adjustment                  Float?
  balance                     Float?
  paymentAmount               Float?
  creditedAmount              Float?
  writtenoffAmount            Float?
  exchangeRate                Float?
  taxAmountWithheld           Float?
  isInclusiveTax              Boolean?
  createdAt                   DateTime   @default(now())
  updatedAt                   DateTime   @updatedAt

  // Relations
  customer                    Contact?   @relation(fields: [customerId], references: [id])
  branch                      Branch?    @relation(fields: [branchId], references: [id])
  warehouse                   Warehouse? @relation(fields: [warehouseId], references: [id])
  writtenoffExpenseAccount    Account?   @relation(fields: [writtenoffExpenseAccountId], references: [id])
  pdfTemplate                 PdfTemplate? @relation(fields: [pdfTemplateId], references: [id])

  entries                     ItemEntry[]        @relation("SaleInvoiceEntries")
  transactions                AccountTransaction[] @relation("SaleInvoiceTransactions")
  costTransactions           InventoryCostLotTracker[] @relation("SaleInvoiceCostTransactions")
  paymentEntries              PaymentReceiveEntry[] @relation("SaleInvoicePayments")
  taxes                       TaxRateTransaction[] @relation("SaleInvoiceTaxes")
  attachments                 Document[]          @relation("SaleInvoiceAttachments")
  matchedBankTransaction      MatchedBankTransaction[] @relation("SaleInvoiceBankMatch")
  paymentMethods              TransactionPaymentServiceEntry[] @relation("SaleInvoicePaymentMethods")

  @@map("sales_invoices")
}


// ===========================================
// SYSTEM MODELS  
// ===========================================
model Tenant {
  id             Int              @id @default(autoincrement())
  organizationId String          @unique @default(dbgenerated()) // Can customize if you want to match uniqid
  createdAt      DateTime        @default(now())
  updatedAt      DateTime        @updatedAt

  initializedAt  DateTime?       
  seededAt       DateTime?
  buildJobId     String?         
  upgradeJobId   String?

  // Relations
  subscriptions  PlanSubscription[] 
  metadata       TenantMetadata?     @relation(fields: [id], references: [tenantId])

  @@map("tenants") // Map to actual table name if needed
}

model TenantMetadata {
  id           Int     @id @default(autoincrement())
  tenantId     Int     @unique
  name         String
  industry     String?
  location     String?
  baseCurrency String
  language     String?
  timezone     String?
  dateFormat   String?
  fiscalYear   String?
  primaryColor String?   // e.g., hex like "#ffffff"
  logoKey      String?
  address      Json?

  tenant       Tenant  @relation(fields: [tenantId], references: [id])

  @@map("tenantsMetadata")
}

// responsible for (tracking of tenants uploads)
model Import {
  id         Int      @id @default(autoincrement())
  resource   String
  tenantId   Int
  mapping    String
  columns    String
  params     String
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  // Relation to Tenant
  tenant     Tenant   @relation(fields: [tenantId], references: [id])

  @@map("imports")
}

model UserInvite {
  id          Int       @id @default(autoincrement())
  tenantId    Int
  email       String    @db.VarChar(255)
  token       String    @db.VarChar(255)  // Secure invite token (used in link)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  deletedAt   DateTime? // Soft delete support
  acceptedAt  DateTime? // When invite was accepted
  expiredAt   DateTime? // Optional: Set explicitly if you want custom expiration
  
  // Relations
  tenant      Tenant    @relation(fields: [tenantId], references: [id])

  @@index([tenantId])
  @@index([email])
}

model OneClickDemo {
  id         Int      @id @default(autoincrement())
  tenantId   Int?     // Optional: the demo might create a temporary tenant
  email      String?  @db.VarChar(255) // Optional: requester email for the demo
  createdAt  DateTime @default(now())
  expiredAt  DateTime? // If demo is time-bound
  deletedAt  DateTime? // Optional: soft delete

  // Relations
  tenant     Tenant?  @relation(fields: [tenantId], references: [id])

  @@index([tenantId])
  @@index([email])
}

model PasswordReset {
  id        Int      @id @default(autoincrement())
  email     String   @db.VarChar(255) // Email of user requesting reset
  token     String   @db.VarChar(255) // Secure token sent to user
  tenantId  Int?                           // Optional: multi-tenant support
  createdAt DateTime @default(now())

  tenant    Tenant?  @relation(fields: [tenantId], references: [id])

  @@index([email])
  @@index([token])
  @@index([tenantId])
}

model PaymentLink {
  id           Int      @id @default(autoincrement())
  tenantId     Int
  resourceId   Int
  resourceType String   @db.VarChar(100)
  linkId       String   @unique @db.VarChar(255)
  publicity    String   @db.VarChar(50)
  expiryAt     DateTime
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  tenant       Tenant   @relation(fields: [tenantId], references: [id])

  @@index([tenantId])
  @@index([resourceType, resourceId])
}

model StripeAccount {
  id               Int      @id @default(autoincrement())
  tenantId         Int      @unique
  stripeAccountId  String   @db.VarChar(255)
  country          String?  @db.VarChar(2)
  type             String?  @db.VarChar(50)
  detailsSubmitted Boolean  @default(false)
  chargesEnabled   Boolean  @default(false)
  payoutsEnabled   Boolean  @default(false)
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  tenant           Tenant   @relation(fields: [tenantId], references: [id])

  @@index([stripeAccountId])
}

model PlaidItem {
  id           Int      @id @default(autoincrement())
  tenantId     Int
  plaidItemId  String   @unique
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  tenant       Tenant   @relation(fields: [tenantId], references: [id])

  @@index([tenantId])
}

model User {
  id                Int       @id @default(autoincrement())
  firstName         String
  lastName          String
  email             String    @unique
  password          String
  verified          Boolean   @default(false)
  inviteAcceptedAt  DateTime? 
  deletedAt         DateTime?
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  tenantId          Int
  tenant            Tenant    @relation(fields: [tenantId], references: [id])

  @@index([tenantId])
}

// ===========================================
// SUBSCRIPTION MODELS
// ===========================================
model SubscriptionPlan {
  id               Int               @id @default(autoincrement())
  price            Float
  invoiceInternal  Int
  invoicePeriod    String

  // Optional fields (used in virtual `hasTrial`)
  trialPeriod      Int?             // e.g., 7
  trialInterval    String?          // e.g., "day", "week", "month"

  createdAt        DateTime         @default(now())
  updatedAt        DateTime         @updatedAt

  // Relations
  subscriptions    Subscription[]   @relation("PlanToSubscriptions")

  @@map("subscription_plans")
}

model Subscriptions{
  id                   Int               @id @default(autoincrement())
  lemonSubscriptionId  Int?              // External billing system reference

  startsAt             DateTime?
  endsAt               DateTime?
  trialEndsAt          DateTime?
  canceledAt           DateTime?

  paymentStatus        SubscriptionPaymentStatus

  createdAt            DateTime          @default(now())
  updatedAt            DateTime          @updatedAt

  // Relations
  tenant               Tenant            @relation(fields: [tenantId], references: [id])
  tenantId             Int

  plan                 SubscriptionPlan  @relation("PlanToSubscriptions", fields: [planId], references: [id])
  planId               Int

  @@map("subscription_plan_subscriptions")
}

